apply plugin: 'com.android.application'

static <T> T getExtValue(Project proj, String key, T defaultValue) {
    if (proj.hasProperty(key)) {
        return proj.getProperties().get(key)
    } else {
        return defaultValue
    }
}

static String trimToNull(String value) {
    if (value == null) return null
    def trimmed = value.trim()
    return trimmed.isEmpty() ? null : trimmed
}

static String stripWrappingQuotes(String value) {
    if (value == null || value.length() < 2) return value
    if ((value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))) {
        return value.substring(1, value.length() - 1)
    }
    return value
}

static Map<String, String> parseEnvFile(File envFile) {
    if (envFile == null || !envFile.exists() || !envFile.isFile()) return Collections.emptyMap()
    def result = new HashMap<String, String>()
    envFile.eachLine { String rawLine ->
        def line = rawLine.trim()
        if (line.isEmpty() || line.startsWith('#')) return
        if (line.startsWith('export ')) line = line.substring('export '.length()).trim()
        def eq = line.indexOf('=')
        if (eq <= 0) return
        def key = trimToNull(line.substring(0, eq))
        if (key == null) return
        def value = stripWrappingQuotes(line.substring(eq + 1).trim())
        if (value != null) result.put(key, value)
    }
    return Collections.unmodifiableMap(result)
}

static String calculateApplicationId(Project proj) {
    String addOnName = proj.parent.name
    String defaultId = "wtf.uhoh.newsoftkeyboard."
    if (proj.path.contains('languages')) {
        defaultId += "languagepack.${addOnName}"
    } else if (proj.path.contains('themes')) {
        defaultId += "theme.${addOnName}"
    } else if (proj.path.contains('quicktexts')) {
        defaultId += "quicktexts.${addOnName}"
    } else if (proj.path.contains('ime')) {
        defaultId = 'wtf.uhoh.newsoftkeyboard'
    } else {
        throw new IllegalStateException('Called on an APK project that has an unknown parent')
    }

    return getExtValue(proj, "override_app_id", defaultId)
}

apply from: "${rootDir}/gradle/android_general.gradle"

//copy bundles and APKs to output
android.applicationVariants.configureEach { variant ->
    def bundleProvider = tasks.named("sign${variant.name.capitalize()}Bundle")
    def bundleCopy = tasks.register("copy${variant.name.capitalize()}Aab", Copy)
    bundleCopy.configure { copier ->
        copier.from "${project.buildDir.absolutePath}/outputs/bundle/${variant.name}/${project.name}-${variant.name}.aab"
        copier.destinationDir file("${rootDir.absolutePath}/outputs/bundle/")
        copier.rename ".*", "${project.parent.name}_${variant.name}.aab"
        copier.dependsOn bundleProvider
    }
    bundleProvider.configure {
        finalizedBy(bundleCopy)
    }

    def assembleProvider = tasks.named("assemble${variant.name.capitalize()}")
    def apkCopy = tasks.register("copy${variant.name.capitalize()}Apk", Copy)
    apkCopy.configure { copier ->
        copier.from "${project.buildDir.absolutePath}/outputs/apk/${variant.name}/${project.name}-${variant.name}.apk"
        copier.destinationDir file("${rootDir.absolutePath}/outputs/apk/")
        copier.rename ".*", "${project.parent.name}_${variant.name}.apk"
        copier.dependsOn assembleProvider
    }
    assembleProvider.configure {
        finalizedBy(apkCopy)
    }
}

group calculateApplicationId(project)

android {
    defaultConfig {
        applicationId calculateApplicationId(project)
    }

    namespace calculateApplicationId(project)

    // Signing envs are typically provided via exported env vars (local dev/CI).
    // For local F-Droid publishing setups, the secrets often live in an env file which may not be exported
    // in non-interactive shells (e.g., after reboot). To keep those flows working, we also try reading
    // a best-effort `.env` file (without printing values):
    //  - $FDROID_ENV_FILE (explicit override)
    //  - $ENV_FILE (legacy)
    //  - <repo>/fdroid/.env
    //  - $FDROID_DATA/.env
    //  - $HOME/fdroid/.env
    def signingEnvFileCandidates = [
            trimToNull(System.getenv('FDROID_ENV_FILE')),
            trimToNull(System.getenv('ENV_FILE')),
            "${rootDir.absolutePath}/fdroid/.env",
            trimToNull(System.getenv('FDROID_DATA')) != null ? "${trimToNull(System.getenv('FDROID_DATA'))}/.env" : null,
            "${System.getProperty('user.home')}/fdroid/.env"
    ].findAll { it != null }.collect { new File(it) }
    def signingEnvFile = signingEnvFileCandidates.find { it.exists() && it.isFile() }
    def envFromFile = parseEnvFile(signingEnvFile)

    def envValue = { String name ->
        def fromEnv = trimToNull(System.getenv(name))
        if (fromEnv != null) return fromEnv
        def fromFile = trimToNull(envFromFile.get(name))
        return fromFile
    }

    def keystoreFilePath = envValue("KEY_STORE_FILE") ?: envValue("FDROID_KEYSTORE_FILE")
    def keystoreFile = null
    if (keystoreFilePath != null && !keystoreFilePath.trim().isEmpty()) {
        keystoreFile = file(keystoreFilePath.trim())
    } else {
        def preferredKeystore = file("/tmp/newsoftkeyboard.keystore")
        if (preferredKeystore.exists()) {
            keystoreFile = preferredKeystore
        } else {
            // Common persistent location for local F-Droid setups.
            def fdroidData = envValue("FDROID_DATA")
            def fdroidDataKeystore = fdroidData != null ? file("${fdroidData}/keystore.jks") : null
            def homeFdroidKeystore = file("${System.getProperty('user.home')}/fdroid/keystore.jks")
            if (fdroidDataKeystore != null && fdroidDataKeystore.exists()) {
                keystoreFile = fdroidDataKeystore
            } else if (homeFdroidKeystore.exists()) {
                keystoreFile = homeFdroidKeystore
            } else {
                // Legacy fallback so older local/CI setups keep working.
                keystoreFile = file("/tmp/anysoftkeyboard.keystore")
            }
        }
    }
    // Support both local and F-Droid CI env var names
    def envStorePass = envValue("KEY_STORE_FILE_PASSWORD") ?: envValue("FDROID_KEYSTORE_PASS") ?: envValue("FDROID_KEY_STORE_PASS")
    def envKeyPass = envValue("KEY_STORE_FILE_DEFAULT_ALIAS_PASSWORD") ?: envValue("FDROID_KEY_ALIAS_PASS") ?: envValue("FDROID_KEY_PASS")
    def envAlias = getExtValue(project, 'override_release_key_alias', (envValue("FDROID_KEY_ALIAS") ?: 'fdroidrepo'))

    signingConfigs {
        release {
            if (keystoreFile.exists() && envStorePass && envKeyPass) {
                storeFile keystoreFile
                storePassword envStorePass
                keyAlias envAlias
                keyPassword envKeyPass
                println "Using '${storeFile.absolutePath}' to release APK ${path} (with alias '${keyAlias}')."
            } else if (!keystoreFile.exists()) {
                println "Could not find '${keystoreFile.absolutePath}' file. Release APK will not be signed."
            } else {
                println "Keystore found at '${keystoreFile.absolutePath}', but signing passwords are missing. Set KEY_STORE_FILE_PASSWORD/KEY_STORE_FILE_DEFAULT_ALIAS_PASSWORD or FDROID_KEYSTORE_PASS/FDROID_KEY_ALIAS_PASS. Building unsigned release."
            }
        }
    }

    buildTypes {
        release {
            if (keystoreFile.exists() && envStorePass && envKeyPass) {
                signingConfig signingConfigs.release
            }
            zipAlignEnabled true
            debuggable false
            minifyEnabled false
        }
        debug {
            // Avoid forcing release keystore on debug builds unless explicitly requested.
            if (keystoreFile.exists() && envStorePass && envKeyPass && System.getenv("USE_RELEASE_SIGNING_FOR_DEBUG") == '1') {
                signingConfig signingConfigs.release
            }
        }
    }
}

String publishingTrack = rootProject.getProperties().getOrDefault("onlyPublishSupporting", "")
if (project.ext.shouldBePublished && !publishingTrack.isEmpty()) {
    project.apply plugin: 'com.github.triplet.play'

    play {
        serviceAccountCredentials = file('/tmp/apk_upload_key.json')
    }

    // calculating whether we want to enable publishing now
    def supportedTracks = Arrays.asList(
            'production',
            getExtValue(project, 'openTestingTrackName', ''),
            getExtValue(project, 'closedTestingTrackName', '')
    )

    boolean allowPublishing = supportedTracks.stream()
            .filter({ !it.isBlank()})
            .anyMatch({ (it == publishingTrack) });


    tasks.configureEach { newTask ->
            if (newTask.getClass().name.startsWith('com.github.triplet.gradle.play.tasks.Publish')) {
                println("Task ${newTask.path} publish is ${allowPublishing? 'enabled' : 'disabled'} for track-name is ${publishingTrack}.")
                newTask.enabled(allowPublishing)
            }
        }

    //verifying release-notes file
    File playStoreWhatsNewFile = file("${project.projectDir}/src/main/play/release-notes/en-US/alpha.txt")
    if (!playStoreWhatsNewFile.exists()) {
        throw new FileNotFoundException("Can not find whatsnew file for Play-Store upload at ${playStoreWhatsNewFile}!")
    }

    if (playStoreWhatsNewFile.text.length() > 500) {
        println("Locale ${Locale.getDefault()}")
        println("file encoding ${CharsetToolkit.defaultSystemCharset}")
        println("File contents:")
        println("***${playStoreWhatsNewFile.text}***")
        throw new IllegalStateException("whatsnew file can not be longer than 500 characters! Currently ${playStoreWhatsNewFile.text.length()}")
    }
} else {
}

apply from: "$rootDir/gradle/versioning_apk.gradle"
